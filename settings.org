#+TITLE: Settings
* index :toc:
- [[#load-external-plugins][Load External Plugins]]
- [[#google-translate][Google Translate]]
- [[#editor-settings][Editor Settings]]
  - [[#basic-settings][Basic Settings]]
  - [[#rotate-text][Rotate Text]]
  - [[#improve-multiple-cursors][Improve Multiple Cursors]]
  - [[#yaml][YAML]]
  - [[#open-on-line][Open on Line]]
  - [[#popup][Popup]]
  - [[#avy][Avy]]
  - [[#evil-changes][Evil changes]]
  - [[#window-control][Window Control]]
  - [[#emmet-is-love-emmet-is-life][Emmet is love, emmet is life]]
  - [[#web-mode-stuff][Web Mode Stuff]]
  - [[#switch-args][Switch Args]]
  - [[#vertico][Vertico]]
  - [[#buffer-name-hack][Buffer Name Hack]]
  - [[#fix-iedit][Fix iedit]]
- [[#javascript][Javascript]]
- [[#autocomplete-and-snippets][Autocomplete And Snippets]]
  - [[#functions][Functions]]
  - [[#autocomplete][Autocomplete]]
  - [[#improve-autocomplete][Improve Autocomplete]]
  - [[#snippets][Snippets]]
- [[#ruby][Ruby]]
  - [[#indentation][Indentation]]
  - [[#console][Console]]
  - [[#solargraph][Solargraph]]
  - [[#reset-database][Reset Database]]
  - [[#projectile-rails-is-love][Projectile Rails is love]]
  - [[#better-go-to-definition][Better go to definition]]
  - [[#projectile-custom-finders][Projectile Custom Finders]]
  - [[#rspec-mode][Rspec Mode]]
  - [[#checkers][Checkers]]
  - [[#edit-hacks][Edit Hacks]]
  - [[#add-debug-on-code][Add Debug on code]]
  - [[#copy-class-name][Copy Class Name]]
  - [[#rails-routes-plugin][Rails Routes Plugin]]
  - [[#rails-json-to-hash-plugin][Rails JSON to hash plugin]]
  - [[#rails-i18n-plugin][Rails i18n plugin]]
  - [[#http-code-plugin][HTTP Code Plugin]]
  - [[#rubocop][Rubocop]]
  - [[#method-generator][Method Generator]]
  - [[#toggle-if-single-and-multiline][Toggle if single and multiline]]
  - [[#split-giant-string][Split Giant String]]
  - [[#add-parameter][Add Parameter]]
  - [[#method-refactor][Method Refactor]]
  - [[#create-method-at-point][Create Method At Point]]
  - [[#go-to-rspec-and-activate-compilation][Go to Rspec and activate compilation]]
  - [[#ruby-refactoring-external-plugin][Ruby Refactoring external plugin]]
  - [[#variable-defaults][Variable defaults]]
- [[#ruby-hash-syntax][Ruby Hash Syntax]]
- [[#custom-functions][Custom Functions]]
  - [[#remove-accents][Remove Accents]]
  - [[#current-file-name-for-yas][Current File Name For yas]]
- [[#kubernetes][Kubernetes]]
- [[#solidity][Solidity]]
- [[#load-userorg][Load user.org]]

* Load External Plugins
Loading plugins like rails routes, rails http status, etc.

#+begin_src emacs-lisp

;; Load only after ruby mode
(after! ruby-mode
  (load (expand-file-name "plugins/rails-routes.el" doom-private-dir))
  (load (expand-file-name "plugins/rubocop.el" doom-private-dir))
  (load (expand-file-name "plugins/rails-i18n.el" doom-private-dir))
  (load (expand-file-name "plugins/ruby-json-to-hash.el" doom-private-dir))
  (load (expand-file-name "plugins/miyagi.el" doom-private-dir))
  (load (expand-file-name "plugins/rails-http-status.el" doom-private-dir)))

;; Fixes some bugs in some libraries
(load (expand-file-name "plugins/library-fixes.el" doom-private-dir))
#+end_src
* Google Translate
#+begin_src emacs-lisp
(after! google-translate
  (defun google-translate--search-tkk ()
    "Search TKK."
    (list 430675 2721866130)))

(after! google-translate-default-ui
  (defun google-translate--search-tkk ()
    "Search TKK."
    (list 430675 2721866130)))

(map! :nvi "C-c ! t" 'google-translate-query-translate)
(map! :nvi "C-c ! T" 'google-translate-query-translate-reverse)
(map! :nvi "C-c t" 'google-translate-at-point)
(map! :nvi "C-c T" 'google-translate-at-point-reverse)

(setq google-translate-default-source-language "en")
(setq google-translate-default-target-language "pt")
#+end_src
* Editor Settings
** Basic Settings
*** Open Full screen
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
*** Toggle Case
#+begin_src emacs-lisp
(map! "M-c" 'string-inflection-toggle)
(map! "M-S-c" 'string-inflection-cycle)
#+end_src
*** Indentation
**** Indent with 2 spaces
#+begin_src emacs-lisp
(after! web-mode
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-markup-indent-offset 2))

(after! js2-mode
  (setq js-indent-level 2)
  (setq indent-tabs-mode nil))
#+end_src

**** Indent whole buffer
#+begin_src emacs-lisp
(defun indent-whole-buffer ()
  "INDENT WHOLE BUFFER."
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))

(map! :leader "-" #'indent-whole-buffer)
#+end_src
*** Editor Basics
**** Save with ç or \
#+begin_src emacs-lisp
;; Save all
(defun save-all-buffers ()
  (interactive)
  (save-some-buffers 0))

(map! :n "ç" #'save-all-buffers)
(map! :n "\\" #'save-all-buffers)
#+end_src
**** Previous And Next buffer
#+begin_src emacs-lisp
;; Previous and next buffer
(map! :n "C-," #'previous-buffer)
(map! :n "C-;" #'next-buffer)

#+end_src
**** Drag Stuff
#+begin_src emacs-lisp
(map! :v "K" #'drag-stuff-up)
(map! :v "J" #'drag-stuff-down)
#+end_src
**** Change begginging and end of line
#+begin_src emacs-lisp
(map! :nv "0" #'doom/backward-to-bol-or-indent)
(map! :nv "-" #'end-of-line)
#+end_src

**** Kill buffer
#+begin_src emacs-lisp
(map! :leader "k" #'kill-current-buffer)
#+end_src

**** Navigate in git hunks
#+begin_src emacs-lisp
(map! :nv "]g" #'git-gutter:next-hunk)
(map! :nv "[g" #'git-gutter:previous-hunk)
#+end_src

**** Avy for the Window
#+begin_src emacs-lisp
(map! :nv "C-s" #'evil-avy-goto-char-2)

#+end_src
**** C-j and C-k for the Win
#+begin_src emacs-lisp
(global-set-key (kbd "C-j") (kbd "C-M-n"))
(global-set-key (kbd "C-k") (kbd "C-M-p"))
#+end_src

**** jj to escape insert mode
#+begin_src emacs-lisp
(setq-default evil-escape-key-sequence "jj")
(setq-default evil-escape-delay 0.5)
#+end_src

*** VTerm and shell stuff
C-l to clear v-term
#+begin_src emacs-lisp
(map! :after vterm
      :map vterm-mode-map
      :ni "C-l" #'vterm-clear)

(map! :mode shell-mode-map :leader "l" 'comint-clear-buffer)

(map! :leader "v" #'+vterm/toggle)
(map! :leader "V" #'+vterm/here)


(set-popup-rule! "^\\*\\(vterm\\)?" :ttl nil)

(setq vterm-always-compile-module t)
#+end_src

*** Better Paste
#+begin_src emacs-lisp
(defun better-paste-after ()
  (interactive)
  (yank))

(map! :i "C-v" #'better-paste-after)
#+end_src
*** Treemacs (please, use SPC .)
#+begin_src emacs-lisp
(map! :leader "e" #'+treemacs/toggle)
(map! :leader "E" #'treemacs-find-file)
(map! :map treemacs-mode-map "M-k" #'evil-window-up)
(map! :map treemacs-mode-map "M-j" #'evil-window-down)
(map! :map treemacs-mode-map "M-h" #'evil-window-left)
(map! :map treemacs-mode-map "M-l" #'evil-window-right)

(after! treemacs
  (define-key treemacs-mode-map [mouse-1] #'treemacs-single-click-expand-action))
#+end_src
*** Git Stuff
#+begin_src emacs-lisp
(map! :mode smerge-mode-map :leader "gdo" #'smerge-keep-other)
(map! :mode smerge-mode-map :leader "gdm" #'smerge-keep-mine)
(map! :mode smerge-mode-map :leader "gda" #'smerge-keep-all)
(map! :mode smerge-mode-map :leader "gdc" #'smerge-keep-current)
#+end_src
** Rotate Text
#+begin_src emacs-lisp

(after! rotate-text
  (add-to-list 'rotate-text-words '("valid" "invalid"))
  (add-to-list 'rotate-text-words '("context" "describe"))
  (add-to-list 'rotate-text-symbols '("be_valid" "be_invalid"))
  (add-to-list 'rotate-text-symbols '("belongs_to" "has_many" "has_one"))
  (add-to-list 'rotate-text-symbols '("if" "unless"))
  (add-to-list 'rotate-text-symbols '("greater_than" "greater_than_or_equal_to" "equal_to" "less_than" "less_than_or_equal_to" "other_than" "odd" "even"))
  (add-to-list 'rotate-text-symbols '("to" "not_to")))

#+end_src
** Improve Multiple Cursors
#+begin_src emacs-lisp
(map! :n "C-M-d" #'evil-multiedit-match-all)

(after! evil-multiedit
  (map! :map iedit-occurrence-keymap-default
        "M-D" nil))
#+end_src
** YAML
#+begin_src emacs-lisp
(setq flycheck-yamllintrc ".yamllint.yml")
#+end_src
** Open on Line
#+begin_src emacs-lisp
(defadvice find-file-noselect (around find-file-noselect-at-line
                                      (filename &optional nowarn rawfile wildcards)
                                      activate)
  "Turn files like file.cpp:14 into file.cpp and going to the 14-th line."
  (save-match-data
    (let* ((matched (string-match "^\\(.*\\):\\([0-9]+\\):?$" filename))
           (line-number (and matched
                             (match-string 2 filename)
                             (string-to-number (match-string 2 filename))))
           (filename (if matched (match-string 1 filename) filename))
           (buffer-name ad-do-it))
      (when line-number
        (with-current-buffer buffer-name
          (goto-char (point-min))
          (forward-line (1- line-number)))))))
#+end_src
** Popup
#+begin_src emacs-lisp
(map! :leader "]" '+popup/raise)
#+end_src
** Avy
#+begin_src emacs-lisp
(setq avy-single-candidate-jump t)
#+end_src
** Evil changes
#+begin_src emacs-lisp
(setq evil-want-visual-char-semi-exclusive t)
(add-hook! 'evil-insert-state-exit-hook #'better-jumper-set-jump)
#+end_src

** Window Control
#+begin_src emacs-lisp
(map! :ni "M-k" #'evil-window-up)
(map! :ni "M-j" #'evil-window-down)
(map! :ni "M-h" #'evil-window-left)
(map! :ni "M-l" #'evil-window-right)

(map! :neo "C-<SPC>" #'ace-window)
(map! "M-o" #'evil-window-next)
(map! :map vterm-mode-map :n "C-<SPC>" #'ace-window)

(setq evil-split-window-below t evil-vsplit-window-right t)
#+end_src

** Emmet is love, emmet is life
#+begin_src emacs-lisp
(map! :after web-mode :map web-mode-map :i "C-e" #'emmet-expand-yas)
(map! :after js2-mode :map rjsx-mode-map :i "C-e" #'emmet-expand-yas)
#+end_src

** Web Mode Stuff
#+begin_src emacs-lisp
(map! :after web-mode :map web-mode-map :i "C-e" #'emmet-expand-yas)
(map! :after js2-mode :map rjsx-mode-map :i "C-e" #'emmet-expand-yas)
(map! :after web-mode :map web-mode-map :nvi "C-j" #'web-mode-tag-next)
(map! :after web-mode :map web-mode-map :nvi "C-k" #'web-mode-tag-previous)
(map! :after web-mode :map web-mode-map :i "C-o" #'+web/indent-or-yas-or-emmet-expand)

;; Fixing annoying lose of highlight
(after! web-mode
  (defun msc/save-and-revert-buffer ()
    (interactive)
    (call-interactively 'save-buffer)
    (msc/revert-buffer-noconfirm))

  (map! :mode web-mode-map :leader "j" 'msc/save-and-revert-buffer))

#+end_src
** Switch Args
#+begin_src emacs-lisp
(defun otavio/swap-arg-forward ()
  (interactive)
  (evil-exchange (nth 0 (evil-inner-arg)) (nth 1 (evil-inner-arg)))
  (evil-forward-arg 1)
  (evil-exchange (nth 0 (evil-inner-arg)) (nth 1 (evil-inner-arg))))

(defun otavio/swap-arg-backward ()
  (interactive)
  (evil-exchange (nth 0 (evil-inner-arg)) (nth 1 (evil-inner-arg)))
  (evil-backward-arg 1)
  (evil-exchange (nth 0 (evil-inner-arg)) (nth 1 (evil-inner-arg))))

(map! :n "C-l" #'otavio/swap-arg-forward)
(map! :n "C-h" #'otavio/swap-arg-backward)
#+end_src
** Vertico
#+begin_src emacs-lisp
(after! vertico
  (map! :map vertico-map "C-c C-o" 'embark-collect-snapshot))

#+end_src
** Buffer Name Hack
#+begin_src emacs-lisp

;; Show path of file on SPC ,
(setq uniquify-buffer-name-style 'reverse)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t) ; rename after killing uniquified
(setq uniquify-ignore-buffers-re "^\\*")

#+end_src
** Fix iedit
#+begin_src emacs-lisp
(setq iedit-toggle-key-default nil)
#+end_src

* Javascript
#+begin_src emacs-lisp
(setq emmet-expand-jsx-className? nil)

(defun update-yas-indentation ()
  (setq-local yas-indent-line 'fixed))

(defun set-emmet-class-name ()
  (setq-local emmet-expand-jsx-htmlFor? t)
  (setq-local emmet-expand-jsx-className? t))

(setq lsp-clients-typescript-server-args '("--stdio" "--tsserver-log-file" "/dev/stderr"))

(defun set-js-company ()
  (setq lsp-clients-typescript-server-args '("--stdio" "--tsserver-log-file" "/dev/stderr"))
  (setq-local +lsp-company-backends '(:separate company-capf company-dabbrev-code company-yasnippet)))

(add-hook! 'rjsx-mode-hook 'set-emmet-class-name)
(add-hook! 'yaml-mode-hook 'update-yas-indentation)
(add-hook! 'rjsx-mode-hook 'set-js-company)
#+end_src

* Autocomplete And Snippets
** Functions
#+begin_src emacs-lisp
(defun company-complete-if-selected ()
  (interactive)
  (if (eq company-selection nil) (newline-and-indent) (company-complete)))
#+end_src

** Autocomplete
#+begin_src emacs-lisp
(map! :i "C-p" #'dabbrev-expand)
(map! :i "C-o" #'yas-expand)

(after! company
  (setq company-dabbrev-downcase nil)
  (setq company-show-numbers t)
  (setq company-idle-delay 0))

(setq company-dabbrev-code-everywhere t)
(setq company-dabbrev-code-other-buffers t)

(map! :after company
      :map company-tng-map
      "C-o" 'yas-expand
      "C-p" 'dabbrev-expand
      "<C-SPC>" 'company-complete-if-selected)

#+end_src
** Improve Autocomplete
#+begin_src emacs-lisp
(defun j-company-remove-dabbrev-dups-keep-order (candidates)
  "Loop over CANDIDATES and remove duplicate candidates if they belong to
  `company-dabbrev' or `company-dabbrev-code'."
  (let ((hash (make-hash-table :test 'equal :size (length candidates)))
        (new-list nil))
    (dolist (candidate candidates)
      (let ((stripped-candidate (substring-no-properties candidate))
            (candidate-backend (get-text-property 0 'company-backend candidate)))
        (cond
         ;; Candidate is `company-yasnippet', always push this.
         ((eq (get-text-property 0 'company-backend candidate)
              'company-yasnippet)
          (push candidate new-list))
         ;; Candidate has not been seen.
         ((not (gethash stripped-candidate hash))
          (puthash stripped-candidate candidate hash)
          (push candidate new-list))
         ;; Candidate has been seen.
         ;; `company-dabbrev' or `company-dabbrev-code' is the candidate.
         ((or candidate-backend
              (eq candidate-backend 'company-dabbrev-code)
              (eq candidate-backend 'company-dabbrev))
          t)
         ;; Candidate has been seen but is not `company-dabbrev'
         ;; or `company-dabbrev-code'.
         (:seen-but-candidate-not-dabbrev
          ;; If the candidate in the hash table is dabbrev, replace it.
          ;; Otherwise, we are fine with duplicates as long as the backends
          ;; are meaningful.
          (let* ((hash-candidate (gethash stripped-candidate hash))
                 (hash-backend (get-text-property
                                0 'company-backend hash-candidate)))
            (if (or hash-backend
                    (eq hash-backend 'company-dabbrev)
                    (eq hash-backend 'company-dabbrev-code))
                (progn
                  (setcar
                   (nthcdr
                    (cl-position hash-candidate new-list :test 'eq)
                    new-list)
                   candidate)
                  (puthash stripped-candidate candidate hash)
                  t)
              ;; Only need one candidate in the hash table.
              (push candidate new-list)))))))
    (reverse new-list)))

(after! company
  (set-company-backend! 'inf-ruby-mode 'company-dabbrev-code)
  (setq +lsp-company-backends '(:separate company-dabbrev-code company-capf company-yasnippet))

  (add-to-list 'company-transformers
               #'j-company-remove-dabbrev-dups-keep-order))
#+end_src
** Snippets
#+begin_src emacs-lisp
(defun select-and-yas-next ()
  (interactive)
  (if (eq company-selection nil)
      (yas-next-field)
    (progn (company-complete-selection) (yas-next-field))))

(defun select-and-yas-previous ()
  (interactive)
  (if (eq company-selection nil)
      (yas-prev-field)
    (progn (company-complete-selection) (yas-prev-field))))

(defun yas-emmet-expand ()
  (interactive)
  (if (eq major-mode 'web-mode)
      (emmet-expand)
    (when (eq major-mode 'ruby-mode) (otavio/grb))))

(map! :after yasnippet
      :map yas-keymap
      "C-o" #'select-and-yas-next
      "C-S-o" #'select-and-yas-previous
      "<tab>" nil
      "<S-tab>" nil
      "C-d" #'yas-skip-and-clear-field
      "C-e" #'yas-emmet-expand)

#+end_src
* Ruby
** Indentation
#+begin_src emacs-lisp
(defvar ruby-indent-to-hook 2)

(add-hook 'ruby-mode-hook
          (lambda ()
            (setq-local ruby-indent-level ruby-indent-to-hook)))
#+end_src
** Console
#+begin_src emacs-lisp
(defun popserver-when-on-byebug (_SYMBOL NEWVAL _OPERATION _WHERE)
  (when (and (eq NEWVAL 0) (cl-search "projectile-rails" (buffer-name)))
    (progn (switch-to-buffer (buffer-name))
           (goto-char (point-max))
           (when (featurep 'evil)
             (evil-insert-state)))))

(add-variable-watcher 'inf-ruby-at-top-level-prompt-p 'popserver-when-on-byebug)
#+end_src
** Solargraph
#+begin_src emacs-lisp
(after! lsp-mode
  (setq lsp-auto-guess-root t)
  (setq lsp-solargraph-formatting nil)
  (setq lsp-solargraph-symbols nil)
  (setq lsp-solargraph-folding nil))
#+end_src
** Reset Database
#+begin_src emacs-lisp
(after! ruby-mode
  (defvar rails-reset-command "rails db:environment:set RAILS_ENV=development; rails db:drop db:create db:migrate;rails db:seed"
    "Command to reset rails")

  (defun otavio/kill-ruby-instances ()
    (interactive)
    (async-shell-command "killall -9 rails ruby spring bundle; echo 'Ruby Instances Killed!'" "*Ruby Kill Output*"))

  (defun otavio/reset-rails-database ()
    (interactive)
    (message "Rails database is being reseted!")
    (async-shell-command (concat rails-reset-command "; echo 'Rails database reseted, please close this popup'" )"*Ruby Reset Output*")
    (+popup/raise "*Ruby Reset Output*"))

  (set-popup-rule! "^\\*\\(Ruby Kill Output\\)?" :ttl nil)
  (set-popup-rule! "^\\*\\(Ruby Reset Output\\)?" :ttl nil)

  (defun otavio/rails-reset-all ()
    (interactive)
    (otavio/kill-ruby-instances)
    (run-at-time "30 seconds" nil #'start-rails-console-in-time)
    (otavio/reset-rails-database))

  (map! :after ruby-mode :mode ruby-mode :localleader "ww" #'otavio/rails-reset-all)
  (map! :after ruby-mode :mode ruby-mode :localleader "wk" #'otavio/kill-ruby-instances))

#+end_src
** Projectile Rails is love
#+begin_src emacs-lisp
(require 'projectile-rails)
(map! :leader "r" #'projectile-rails-command-map)

(after! which-key
  (push '((nil . "projectile-rails-\\(.+\\)") . (nil . "\\1"))
        which-key-replacement-alist))

#+end_src
** Better go to definition
#+begin_src emacs-lisp
(after! robe
  (set-lookup-handlers! 'ruby-mode
    :definition '(projectile-rails-goto-file-at-point robe-jump)
    :documentation #'robe-doc))

(after! ruby-mode
  (set-lookup-handlers! 'ruby-mode
    :definition '(projectile-rails-goto-file-at-point robe-jump)
    :documentation #'robe-doc))

(after! web-mode
  (set-lookup-handlers! 'web-mode
    :definition '(projectile-rails-goto-file-at-point rails-routes-jump)))
#+end_src
** Projectile Custom Finders
#+begin_src emacs-lisp
;;; projectile-rails-remaps.el -*- lexical-binding: t; -*-

(after! projectile-rails
  (setq projectile-rails-expand-snippet-with-magic-comment t)

  (defun projectile-rails-find-admin ()
    "Find a model."
    (interactive)
    (projectile-rails-find-resource
     "admin: "
     '(("app/admin/" "\\(.+\\)\\.rb$"))
     "app/admin/${filename}.rb"))

  (defun projectile-rails-find-current-admin ()
    "Find a model for the current resource."
    (interactive)
    (projectile-rails-find-current-resource "app/admin/"
                                            "${singular}\\.rb$"
                                            'projectile-rails-find-admin))

  (defun projectile-rails-find-business-or-service ()
    "Find a service."
    (interactive)
    (if (file-exists-p (concat (projectile-project-root) "app/business"))
        (projectile-rails-find-resource
         "business: "
         '(("app/business/" "\\(.+\\)\\.rb$"))
         "app/business/${filename}.rb")
      (if (file-exists-p (concat (projectile-project-root) "app/services"))
          (projectile-rails-find-resource
           "service: "
           '(("app/services/" "\\(.+\\)\\.rb$"))
           "app/services/${filename}.rb"))))

  (defun projectile-rails-find-service ()
    "Find all in graphql."
    (interactive)
    (projectile-rails-find-resource
     "service: "
     '(("app/services/" "\\(.+\\)\\.rb$"))
     "app/services/${filename}.rb"))

  (defun otavio/go-to-latest-migration ()
    (interactive)
    (find-file (aj-fetch-latest (concat (doom-project-root) "db/migrate/"))))

  (defun aj-fetch-latest (path)
    (let ((e (f-entries path)))
      (car (sort e (lambda (a b)
                     (not (time-less-p (aj-mtime a)
                                       (aj-mtime b))))))))

  (defun aj-mtime (f) (let ((attrs (file-attributes f))) (nth 5 attrs)))

  (defun projectile-rails-find-graphql-all ()
    "Find all in graphql."
    (interactive)
    (projectile-rails-find-resource
     "graphql: "
     '(("app/graphql/" "\\(.+\\)\\.rb$"))
     "app/graphql/${filename}.rb"))

  (map! :leader "rd" #'otavio/go-to-latest-migration)
  (map! :leader "rt" #'projectile-rails-find-admin)
  (map! :leader "rT" #'projectile-rails-find-current-admin)
  (map! :leader "rs" #'projectile-rails-find-business-or-service)
  (map! :leader "rS" #'projectile-rails-find-service)
  (map! :leader "rq" #'projectile-rails-find-graphql-all))
#+end_src

#+RESULTS:
: projectile-rails-find-graphql-all

** Rspec Mode
*** Basic Config
#+begin_src emacs-lisp
(after! rspec-mode
  (set-popup-rule! "^\\*\\(rspec-\\)?compilation" :size 0.5 :ttl nil :select t))

(after! rspec-mode
  (map! :leader "t" #'rspec-mode-keymap)
  (map! :leader "tl" #'rspec-run-last-failed)
  (map! :leader "tg" #'rspec-run-git-diff-from-head)
  (map! :leader "tG" #'rspec-run-git-diff-from-master))

(map! :mode ruby-mode-map :leader "a" 'goto-test)
(map! :mode ruby-mode-map :leader "A" 'goto-test-and-vsplit)
#+end_src
*** Super Goto test
#+begin_src emacs-lisp
(defun file-path-to-test (filename)
  (if (string-match-p "/spec/" filename)
      (if (string-match-p "/admin/" filename)
          (concat
           (replace-regexp-in-string "/spec/controllers/" "/app/" (file-name-directory filename))
           (singularize-string (replace-regexp-in-string "_controller_spec" "" (file-name-base filename)))
           "."
           (file-name-extension filename))
        (concat
         (replace-regexp-in-string "/spec/" "/app/" (file-name-directory filename))
         (replace-regexp-in-string "_spec" "" (file-name-base filename))
         "."
         (file-name-extension filename)))
    (if (string-match-p "/admin/" filename)
        (concat
         (replace-regexp-in-string "/app/" "/spec/controllers/" (file-name-directory filename))
         (pluralize-string (file-name-base filename))
         "_controller_spec."
         (file-name-extension filename))
      (concat
       (replace-regexp-in-string "/app/" "/spec/" (file-name-directory filename))
       (file-name-base filename)
       "_spec."
       (file-name-extension filename)))))

(defun goto-test-and-vsplit ()
  (interactive)
  (if (string-match-p "/spec/" buffer-file-name) (find-file (file-path-to-test buffer-file-name)))
  (delete-other-windows)
  (evil-window-vsplit)
  (if (string-match-p "/app/" buffer-file-name) (find-file (file-path-to-test buffer-file-name))))

(defun goto-test ()
  (interactive)
  (find-file (file-path-to-test buffer-file-name)))

(map! :mode ruby-mode-map :leader "a" 'goto-test)
(map! :mode ruby-mode-map :leader "A" 'goto-test-and-vsplit)
#+end_src
** Checkers
#+begin_src emacs-lisp
;; make flycheck use bundle instead of rubocop latest version
(defun project-has-rubocop ()
  (let ((found nil))
    (cl-block find-rubocop
      (mapc (lambda (line) (when (string-match "rubocop" line) (setq found t) (cl-return-from find-rubocop)))
            (with-temp-buffer
              (insert-file-contents (concat (projectile-project-root) "Gemfile.lock"))
              (split-string (buffer-string) "\n" t))))
    found))

(defvar rubocop-append-command '("bundle" "exec")
  "Commands to run before rubocop")

(add-hook 'ruby-mode-hook
          (lambda ()
            (if (and (not (eq (projectile-project-root) nil)) (file-exists-p (concat (projectile-project-root) "Gemfile.lock")) (project-has-rubocop))
                (progn
                  (setq-local flycheck-checker 'ruby-rubocop)
                  (setq-local flycheck-command-wrapper-function
                              (lambda (command) (append rubocop-append-command command))))

              (setq-local flycheck-disabled-checkers '(ruby-reek ruby-rubylint ruby-rubocop)))))

(defvar ruby-disabled-checkers '(ruby-reek lsp ruby-rubylint) "Checkers to automatically disable on ruby files.")

(add-hook! 'ruby-mode-hook (setq-local flycheck-disabled-checkers ruby-disabled-checkers))
#+end_src
** Edit Hacks
#+begin_src emacs-lisp
(map! :map ruby-mode-map
      "C-k" #'ruby-beginning-of-block
      "C-j" #'ruby-end-of-block)

(after! evil
  (define-key evil-normal-state-map (kbd "g S") #'multi-line)
  (define-key evil-normal-state-map (kbd "g J") #'multi-line-single-line))

#+end_src

** Add Debug on code
#+begin_src emacs-lisp
(defvar debugger-command "byebug")
(defvar pry-show-helper t)

(defun otavio/remove-all-debuggers ()
  (interactive)
  (setq CURRENT_LINE (line-number-at-pos))
  (setq DELETATIONS 0)
  (goto-char (point-min))
  (while (search-forward debugger-command (point-max) t)
    (beginning-of-line)
    (kill-line 1)
    (setq DELETATIONS (1+ DELETATIONS)))
  (goto-char (point-min))
  (forward-line (- (1- CURRENT_LINE) DELETATIONS)))

(defun otavio/insert-debugger ()
  (interactive)
  (setq HELPER (if pry-show-helper " # next; step; break; break 14;break FooBar#func;break --help;" ""))
  (setq REAL_COMMAND (if (eq major-mode 'ruby-mode) (concat debugger-command HELPER) (concat "<% " debugger-command HELPER " %>")))
  (back-to-indentation)
  (newline-and-indent)
  (forward-line -1)
  (insert REAL_COMMAND)
  (indent-according-to-mode)
  (save-buffer))

(map! :after ruby-mode :mode ruby-mode :leader "d" 'otavio/insert-debugger)
(map! :after ruby-mode :mode ruby-mode :leader "D" 'otavio/remove-all-debuggers)
(map! :after web-mode :mode web-mode-map :leader "d" 'otavio/insert-debugger)
(map! :after web-mode :mode web-mode-map :leader "D" 'otavio/remove-all-debuggers)
#+end_src

** Copy Class Name
#+begin_src emacs-lisp
(after! ruby-mode
  ;; SPC m C to copy class name, super useful to test things on console.
  (defun endless/-ruby-symbol-at-point ()
    (let ((l (point)))
      (save-excursion
        (forward-sexp 1)
        (buffer-substring l (point)))))

  (defun endless/ruby-copy-class-name ()
    (interactive)
    (save-excursion
      (let ((name nil)
            (case-fold-search nil))
        (skip-chars-backward (rx (syntax symbol)))
        (when (looking-at-p "\\_<[A-Z]")
          (setq name (endless/-ruby-symbol-at-point)))
        (while (ignore-errors (backward-up-list) t)
          (when (looking-at-p "class\\|module")
            (save-excursion
              (forward-word 1)
              (skip-chars-forward "\r\n[:blank:]")
              (setq name (if name
                             (concat (endless/-ruby-symbol-at-point) "::" name)
                           (endless/-ruby-symbol-at-point))))))
        (kill-new name)
        (message "Copied %s" name))))

  ;; binding it to SPC m c
  (map! :map ruby-mode-map :localleader "C" #'endless/ruby-copy-class-name)
  (map! :map ruby-mode-map :localleader "c" #'endless/ruby-copy-class-name))
#+end_src
** Rails Routes Plugin
#+begin_src emacs-lisp
(after! web-mode
  (define-key web-mode-map (kbd "C-c o") #'rails-routes-insert)
  (define-key web-mode-map (kbd "C-c C-o") #'rails-routes-insert-no-cache))

(after! ruby-mode
  (map! :mode ruby-mode "C-c o" #'rails-routes-insert)
  (map! :mode ruby-mode "C-c C-o" #'rails-routes-insert-no-cache))

(define-key evil-normal-state-map (kbd "g a") #'rails-routes-jump)
(define-key evil-visual-state-map (kbd "g a") #'rails-routes-jump)

(rails-routes-global-mode)
#+end_src
** Rails JSON to hash plugin
#+begin_src emacs-lisp
;; On doom emacs
(map! :mode ruby-mode :localleader "J" 'ruby-json-to-hash-parse-json) ;; Parse the json, SPC m J
(map! :mode ruby-mode :localleader "j" 'ruby-json-to-hash-toggle-let) ;; Create a let or send the let back to parent. SPC m j
#+end_src
** Rails i18n plugin
#+begin_src emacs-lisp
(map! :map ruby-mode-map "C-c i" 'rails-i18n-insert-with-cache) ;; Search with cache on ruby mode
(map! :map ruby-mode-map "C-c C-i" 'rails-i18n-insert-no-cache) ;; Search refresh cache on ruby modee
(map! :map web-mode-map "C-c i" 'rails-i18n-insert-with-cache) ;; Search with cache on web-mode
(map! :map web-mode-map "C-c C-i" 'rails-i18n-insert-no-cache) ;; Search refresh cache web-mode

(rails-i18n-global-mode)
#+end_src
** HTTP Code Plugin
#+begin_src emacs-lisp
(define-key ruby-mode-map (kbd "C-c s") #'rails-http-statues-insert-symbol)
(define-key ruby-mode-map (kbd "C-c S") #'rails-http-statues-insert-code)
#+end_src

** Rubocop
#+begin_src emacs-lisp

(defun msc/revert-buffer-noconfirm ()
  "Call `revert-buffer' with the NOCONFIRM argument set."
  (interactive)
  (revert-buffer nil t))

(defun rubocop-on-current-file ()
  "RUBOCOP ON CURRENT_FILE."
  (interactive)
  (save-buffer)
  (message "%s" (shell-command-to-string
                 (concat "bundle exec rubocop -a "
                         (shell-quote-argument (buffer-file-name)))))
  (msc/revert-buffer-noconfirm))

(map! :map ruby-mode-map :localleader "d" 'rubocop-toggle-at-point)
(map! :mode ruby-mode-map :leader "=" #'rubocop-on-current-file)
#+end_src
** Method Generator
#+begin_src emacs-lisp
(defun otavio/chomp (str)
  "Trim leading and trailing whitespace from STR."
  (replace-regexp-in-string "\\(\\`[[:space:]\n]*\\|[[:space:]\n]*\\'\\)" "" str))

(defun otavio/delete-current-line ()
  "Delete (not kill) the current line."
  (interactive)
  (save-excursion
    (delete-region
     (progn (forward-visible-line 0) (point))
     (progn (forward-visible-line 1) (point)))))

(defun otavio/grb ()
  (interactive)
  (setq line-text (buffer-substring (line-beginning-position) (line-end-position)))
  (setq splitted-string (s-split ";" line-text))
  (delete-region (line-beginning-position) (line-end-position))
  (dolist (item splitted-string)
    (setq splitted-item (s-split "\\@" (otavio/chomp item)))
    (setq method-name (nth 0 splitted-item))
    (if (equal method-name "init")
        (setq method-name "initialize"))
    (insert (concat "def " method-name))
    (if (eq (length splitted-item) 2)
        (progn
          (insert "(")
          (dolist (arg (s-split "," (nth 1 splitted-item)))
            (insert (concat arg ", ")))
          (delete-char -2)
          (insert ")")))
    (indent-region (line-beginning-position) (line-end-position))
    (newline)
    (if (eq (length splitted-item) 2)
        (if (equal (nth 0 splitted-item) "init")
            (progn
              (dolist (arg (s-split "," (nth 1 splitted-item)))
                (insert (concat "@" arg " = " arg))
                (indent-region (line-beginning-position) (line-end-position))
                (newline)
                )))
      )

    (insert "end")
    (indent-region (line-beginning-position) (line-end-position))
    (newline)
    (newline))
  (otavio/delete-current-line)
  (forward-line -1)
  (otavio/delete-current-line)
  (forward-line -2)
  (end-of-line)
  (newline-and-indent))

(map! :after ruby-mode :map ruby-mode-map :i "C-e" #'otavio/grb)
#+end_src
** Toggle if single and multiline
#+begin_src emacs-lisp
(defun otavio/-current-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at-p "[[:space:]]*$")))

(defun otavio/-swap-search-forward-swap-to-singleline (SEARCH)
  (if (search-backward SEARCH (line-beginning-position) t)
      (progn
        (kill-visual-line)
        (forward-line 1)
        (end-of-line)
        (insert " ")
        (yank)
        (indent-according-to-mode)
        (forward-line 1)
        (kill-line)
        (kill-line)
        (forward-line -2)
        (kill-line)
        (forward-to-indentation 0)
        t)))

(defun otavio/-swap-search-forward-swap-to-multiline (SEARCH)
  (if (search-forward SEARCH (line-end-position) t)
      (progn
        (backward-word)
        (backward-char)
        (kill-visual-line)
        (forward-line -1)
        (if (not (otavio/-current-line-empty-p))
            (progn
              (end-of-line)))
        (newline)
        (yank)
        (indent-according-to-mode)
        (forward-line 1)
        (indent-according-to-mode)
        (end-of-line)
        (newline)
        (insert "end")
        (indent-according-to-mode)
        t)))

(defun otavio/swap-if-unless-ruby ()
  (interactive)
  (beginning-of-line)
  (forward-word)
  (setq CHANGED nil)
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-multiline " if ")))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-multiline " unless ")))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "if")))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "unless")))
  (if (not CHANGED)
      (progn
        (forward-line -1)
        (beginning-of-line)
        (forward-word)))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "if")))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "unless")))
  (if (not CHANGED)
      (progn
        (forward-line -1)
        (beginning-of-line)
        (forward-word)))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "if")))
  (if (not CHANGED)
      (setq CHANGED (otavio/-swap-search-forward-swap-to-singleline "unless"))))

(map! :after ruby-mode :map ruby-mode-map :localleader "i" #'otavio/swap-if-unless-ruby)
#+end_src
** Split Giant String
#+begin_src emacs-lisp
(defvar split-ruby-giant-string-default 125)

(defun otavio/split-ruby-giant-string (&optional line-split-real)
  (interactive)
  (if (not line-split-real)
      (setq line-split-real (read-number "split in column:" split-ruby-giant-string-default)))
  (setq line-split (- line-split-real 3))
  (move-to-column line-split)
  (setq char-at-point-is-closing (eq ?\" (char-after)))
  (if (not char-at-point-is-closing)
      (if (eq (current-column) line-split)
          (progn
            ;; Start refactoring
            (if (< (+ (current-indentation) 5 (length (word-at-point))) line-split)
                (backward-word))
            (insert "\"\"")
            (backward-char)
            (newline)
            (forward-line -1)
            (end-of-line)
            (insert " \\")
            (forward-line 1)
            (indent-according-to-mode)
            (end-of-line)
            (if (> (current-column) line-split-real)
                (otavio/split-ruby-giant-string line-split-real)
              )
            )
        )))

(map! :after ruby-mode :map ruby-mode-map :localleader "S" #'otavio/split-ruby-giant-string)
#+end_src
** Add Parameter
#+begin_src emacs-lisp
(defun ruby-add-parameter--with-existing-parameters (args)
  (interactive)
  (forward-char -1)
  (insert ", " args))

(defun ruby-add-parameter--without-existing-parameters (args)
  (interactive)
  (call-interactively 'end-of-line)
  (insert "(" args ")"))

(defun ruby-add-parameter ()
  (interactive)
  (let (
        (args (read-string "Please enter the parameters that you want to add (separated by commma): "))
        )
    (when (not (string= args ""))
      (save-excursion
        (+evil/previous-beginning-of-method 1)
        (if (search-forward ")" (point-at-eol) t)
            (ruby-add-parameter--with-existing-parameters args)
          (ruby-add-parameter--without-existing-parameters args))))))

(map! :after ruby-mode :mode ruby-mode :localleader "a" #'ruby-add-parameter)
#+end_src
** Method Refactor
#+begin_src emacs-lisp
(defun ruby-extract-function ()
  (interactive)
  (let* ((function-name (read-string "Method name? "))
         (args (read-string "Arguments without paranthesis (leave blank for no parameters): ")))

    (when (not (string= function-name ""))
      (call-interactively 'evil-change)
      (call-interactively 'evil-normal-state)
      (ruby-extract-function--create-function function-name args)
      (ruby-extract-function--insert-function function-name args)
      )))

(defun ruby-extract-function--insert-function (function-name args)
  (when (not (eq (point) (point-at-eol)))
    (evil-forward-char))
  (insert function-name)
  (when (not (string= args ""))
    (insert "(" args ")"))
  (evil-indent (point-at-bol) (point-at-eol)))

(defun ruby-extract-function--create-function (function-name args)
  (save-excursion
    (+evil/next-end-of-method)
    (when (not (string= (string (following-char)) "\n"))
      (+evil/insert-newline-above 1))
    (+evil/insert-newline-below 1)
    (forward-line 1)
    (insert "def " function-name)
    (when (not (string= args ""))
      (insert "(" args ")"))
    (evil-indent (point-at-bol) (point-at-eol)) (+evil/insert-newline-below 1) (forward-line 1)
    (insert "end") (evil-indent (point-at-bol) (point-at-eol))
    (+evil/insert-newline-above 1) (+evil/insert-newline-below 1)
    (forward-line -1)
    (evil-paste-after 1)
    (forward-line -1)
    (when (string= (string (following-char)) "\n") (delete-char 1))
    (+evil/reselect-paste)
    (call-interactively 'evil-indent)))

(map! :after ruby-mode :mode ruby-mode :localleader "m" #'ruby-extract-function)
#+end_src
** Create Method At Point
#+begin_src emacs-lisp
(defun ruby-new-method-from-symbol-at-point ()
  (interactive)
  (better-jumper-set-jump)
  (when (looking-at-p "\\sw\\|\\s_")
    (forward-sexp 1))
  (forward-sexp -1)
  (let* ((variable-start-point (point))
         (variable-end-point nil)
         (variable-name (save-excursion (forward-sexp 1) (setq variable-end-point (point)) (buffer-substring-no-properties variable-start-point (point))))
         (has-arguments (save-excursion (goto-char variable-end-point) (looking-at-p "(")))
         (arguments (ruby-new-method-from-symbol-at-point--get-arguments has-arguments variable-end-point))
         )
    (ruby-new-method-from-symbol-at-point--create-method variable-name (string-join (remove nil arguments) ", "))
    ))

(defun ruby-new-method-from-symbol-at-point--create-method (function-name args)
  (+evil/next-end-of-method)
  (when (not (string= (string (following-char)) "\n"))
    (+evil/insert-newline-above 1))
  (+evil/insert-newline-below 1)
  (forward-line 1)
  (insert "def " function-name)
  (when (not (string= args ""))
    (insert "(" args ")"))
  (evil-indent (point-at-bol) (point-at-eol)) (+evil/insert-newline-below 1) (forward-line 1)
  (insert "end") (evil-indent (point-at-bol) (point-at-eol))
  (+evil/insert-newline-above 1) (+evil/insert-newline-below 1)
  (forward-line -1)
  (when (featurep 'evil)
    (evil-change (point) (point))) (indent-for-tab-command)
  (message "Method created!  Pro Tip:  Use C-o (normal mode) to jump back to the method usage."))

(defun ruby-new-method-from-symbol-at-point--get-arguments (has-arguments variable-end-point)
  (when has-arguments
    (let* ((start-args-point nil)
           (end-args-point nil)
           (args-raw nil)
           )
      (save-excursion (goto-char variable-end-point) (evil-forward-word-begin) (setq start-args-point (point)) (evil-backward-word-end)
                      (evil-jump-item)
                      (setq end-args-point (point)))
      (setq args-raw (buffer-substring-no-properties start-args-point end-args-point))
      (mapcar
       (lambda (argument)
         (if (string-match-p "(...)" argument)
             (read-string (concat "name for " argument " argument:  "))
           (ruby-new-method-from-symbol-at-point--verify-exist argument))
         ) (mapcar 'string-trim (split-string (replace-regexp-in-string "(.*)" "(...)" args-raw) ","))))))

(defun ruby-new-method-from-symbol-at-point--verify-exist (argument)
  (save-excursion
    (if (or (search-backward-regexp (concat "def " argument "\\(\(\\|$\\)") (point-min) t)
            (search-forward-regexp (concat "def " argument "\\(\(\\|$\\)") (point-max) t))
        nil
      (if (eq 0 (length (let ((case-fold-search nil))
                          (remove "" (split-string argument "[a-z]+\\(_[a-z]+\\)*")))))
          (if (or (string= argument "false")
                  (string= argument "true"))
              (read-string (concat "name for " argument " boolean:  ")) argument)
        (read-string (concat "name for " argument " expression:  "))))))

(map! :after ruby-mode :mode ruby-mode :localleader "n" #'ruby-new-method-from-symbol-at-point)
#+end_src
** Go to Rspec and activate compilation
#+begin_src emacs-lisp
#+end_src
** Ruby Refactoring external plugin
#+begin_src emacs-lisp
(require 'ruby-refactor)

(add-hook! 'ruby-mode-hook 'ruby-refactor-mode-launch)

(after! ruby-refactor
  (map! :mode ruby-mode :localleader "v" 'ruby-refactor-extract-local-variable)
  (map! :mode ruby-mode :localleader "V" 'ruby-refactor-extract-constant)

  (defun ruby-refactor-extract-local-variable(  )
    "Extracts selected text to local variable"
    (interactive)
    (save-restriction
      (save-match-data
        (widen)
        (let* ((text-begin (region-beginning))
               (text-end (region-end))
               (text (ruby-refactor-trim-newline-endings (buffer-substring-no-properties text-begin text-end)))
               (variable-name (read-from-minibuffer "Variable name? ")))
          (delete-region text-begin text-end)
          (insert variable-name)
          (beginning-of-line)
          (open-line 1)
          (ruby-indent-line)
          (insert variable-name " = " text "\n")
          (search-forward variable-name)
          (backward-sexp)))))

  (defun ruby-refactor-extract-constant ()
    "Extracts selected text to a constant at the top of the current class or module"
    (interactive)
    (save-restriction
      (save-match-data
        (widen)
        (let* ((text-begin (region-beginning))
               (text-end (region-end))
               (text (ruby-refactor-trim-newline-endings (buffer-substring-no-properties text-begin text-end)))
               (constant-name (read-from-minibuffer "Constant name? ")))
          (delete-region text-begin text-end)
          (insert constant-name)
          (forward-line -1)
          (beginning-of-line)
          (evil-forward-word-begin)
          (let ((class-at-root (looking-at "class")) (first-character (substring text 0 1)))
            (ruby-refactor-goto-constant-insertion-point)
            (beginning-of-line)
            (if class-at-root
                (progn
                  (open-line 2)
                  (forward-line 1)))
            (ruby-indent-line)
            (if (or (string= "(" first-character)
                    (string= "[" first-character)
                    (string= "{" first-character)
                    (string= "\"" first-character)
                    (string= ":" first-character)
                    (string-match "^[a-zA-Z0-9_]+[_]*[a-zA-Z\w_]*$" text)
                    (string= "'" first-character))
                (insert constant-name " = " text ".freeze" "\n")
              (if (or (string-match "\\.\\." text)
                      (string-match "\\.\\.\\." text)
                      (string-match "\\+" text)
                      (string-match "\\-" text)
                      (not (string-match "^[a-zA-Z0-9_]+[_]*[a-zA-Z\w_]*$" text))
                      (string-match "\\*" text)
                      (string-match "\\*\\*" text))
                  (insert constant-name " = (" text ")" ".freeze" "\n") (insert constant-name " = " text ".freeze" "\n"))
              )

            (evil-indent-line (point-at-bol) (point-at-eol))
            (forward-line 1)
            (search-forward constant-name)
            (backward-sexp)))))))
#+end_src
** Variable defaults
#+begin_src emacs-lisp
(defvar ruby-rspec-describe-class "call")
#+end_src
* Ruby Hash Syntax
#+begin_src emacs-lisp
(after! ruby-mode
  (require 'ruby-hash-syntax)
  (map! :mode ruby-mode :localleader "H" #'ruby-hash-syntax-toggle))
#+end_src
* Custom Functions
** Remove Accents
#+begin_src emacs-lisp
(defun remove-accents (&optional @begin @end)
  "Remove accents in some letters and some
Change European language characters into equivalent ASCII ones, e.g. “café” ⇒ “cafe”.
When called interactively, work on current line or text selection.

URL `http://ergoemacs.org/emacs/emacs_zap_gremlins.html'
Version 2018-11-12"
  (interactive)
  (let (($charMap
         [
          ["ß" "ss"]
          ["á\\|à\\|â\\|ä\\|ā\\|ǎ\\|ã\\|å\\|ą\\|ă\\|ạ\\|ả\\|ả\\|ấ\\|ầ\\|ẩ\\|ẫ\\|ậ\\|ắ\\|ằ\\|ẳ\\|ặ" "a"]
          ["æ" "ae"]
          ["ç\\|č\\|ć" "c"]
          ["é\\|è\\|ê\\|ë\\|ē\\|ě\\|ę\\|ẹ\\|ẻ\\|ẽ\\|ế\\|ề\\|ể\\|ễ\\|ệ" "e"]
          ["í\\|ì\\|î\\|ï\\|ī\\|ǐ\\|ỉ\\|ị" "i"]
          ["ñ\\|ň\\|ń" "n"]
          ["ó\\|ò\\|ô\\|ö\\|õ\\|ǒ\\|ø\\|ō\\|ồ\\|ơ\\|ọ\\|ỏ\\|ố\\|ổ\\|ỗ\\|ộ\\|ớ\\|ờ\\|ở\\|ợ" "o"]
          ["ú\\|ù\\|û\\|ü\\|ū\\|ũ\\|ư\\|ụ\\|ủ\\|ứ\\|ừ\\|ử\\|ữ\\|ự"     "u"]
          ["ý\\|ÿ\\|ỳ\\|ỷ\\|ỹ"     "y"]
          ["þ" "th"]
          ["ď\\|ð\\|đ" "d"]
          ["ĩ" "i"]
          ["ľ\\|ĺ\\|ł" "l"]
          ["ř\\|ŕ" "r"]
          ["š\\|ś" "s"]
          ["ť" "t"]
          ["ž\\|ź\\|ż" "z"]
          [" " " "]       ; thin space etc
          ["–" "-"]       ; dash
          ["—\\|一" "--"] ; em dash etc
          ])
        $begin $end
        )
    (if (null @begin)
        (if (use-region-p)
            (setq $begin (region-beginning) $end (region-end))
          (setq $begin (line-beginning-position) $end (line-end-position)))
      (setq $begin @begin $end @end))
    (let ((case-fold-search t))
      (save-restriction
        (narrow-to-region $begin $end)
        (mapc
         (lambda ($pair)
           (goto-char (point-min))
           (while (search-forward-regexp (elt $pair 0) (point-max) t)
             (replace-match (elt $pair 1))))
         $charMap)))))

(defun remove--accents (@string)
  "Returns a new string. European language chars are changed ot ASCII ones e.g. “café” ⇒ “cafe”.
See `xah-asciify-text'
Version 2015-06-08"
  (with-temp-buffer
    (insert @string)
    (xah-asciify-text (point-min) (point-max))
    (buffer-string)))
#+end_src
** Current File Name For yas
#+begin_src emacs-lisp

(defun current-file-name-for-yas ()
  (interactive)
  (let* ((files (split-string buffer-file-name "/"))
         (file (nth (1- (length files)) files))
         (parsed (split-string file "\\."))
         (model (nth 0 parsed))
         )
    model))
#+end_src
* Kubernetes
#+begin_src emacs-lisp
(use-package! kubernetes
  :config
  (setq kubernetes-poll-frequency 3600
        kubernetes-redraw-frequency 3600))

(use-package! kubernetes-evil)

(map! :leader
      (:prefix "o"
       :desc "Kubernetes" "K" 'kubernetes-overview))
#+end_src
* Solidity
#+begin_src emacs-lisp
(after! solidity-mode
  (set-company-backend! 'solidity-mode '(:separate company-solidity company-dabbrev-code company-yasnippet)))
#+end_src

* Load user.org
#+begin_src emacs-lisp
(if (file-exists-p (expand-file-name "user.org" doom-private-dir))
    (org-babel-load-file
     (expand-file-name "user.org" doom-private-dir))
  (progn
    (shell-command "cp ~/.doom.d/user.example.org ~/.doom.d/user.org")
    (org-babel-load-file
     (expand-file-name "user.org" doom-private-dir))))
#+end_src
